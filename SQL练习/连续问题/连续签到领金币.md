# 百度一面SQL之连续签到领金币

- 已知一张用户行为日志表`tb_user_log`，字段包括`uid-用户ID`、`artical_id-文章ID`、`in_time-进入时间`、`out_time-离开时间`、`sign_in-是否签到`
- **注意1**：只有`artical_id为0时sign_in`值才有效；
- **注意2**：从2021年7月7日0点开始，用户每天签到可以领1金币，并可以开始累积签到天数，连续签到的第3、7天分别可额外领2、6金币，每连续签到7天后重新累积签到天数
- **问题：计算每个用户2021年7月至10月每月获得的金币数**

```java
CREATE TABLE tb_user_log (
    uid INT COMMENT '用户ID',
    artical_id INT COMMENT '视频ID',
    in_time varchar(20) COMMENT '进入时间',
    out_time varchar(20) COMMENT '离开时间',
    sign_in int COMMENT '是否签到'
) ;
 
INSERT INTO tb_user_log(uid, artical_id, in_time, out_time, sign_in) VALUES
  (101, 0, '2021-07-07 10:00:00', '2021-07-07 10:00:09', 1),
  (101, 0, '2021-07-08 10:00:00', '2021-07-08 10:00:09', 1),
  (101, 0, '2021-07-09 10:00:00', '2021-07-09 10:00:42', 1),
  (101, 0, '2021-07-10 10:00:00', '2021-07-10 10:00:09', 1),
  (101, 0, '2021-07-11 23:59:55', '2021-07-11 23:59:59', 1),
  (101, 0, '2021-07-12 10:00:28', '2021-07-12 10:00:50', 1),
  (101, 0, '2021-07-14 10:00:28', '2021-07-13 10:00:50', 1),
  (101, 0, '2021-07-15 11:00:28', '2021-07-14 11:00:50', 1),
  (101, 0, '2021-07-16 11:59:28', '2021-07-16 00:01:20', 1),
  (102, 0, '2021-10-01 10:00:28', '2021-10-01 10:00:50', 1),
  (102, 0, '2021-10-02 10:00:01', '2021-10-02 10:01:50', 1),
  (102, 0, '2021-10-03 11:00:55', '2021-10-03 11:00:59', 1),
  (102, 0, '2021-10-05 11:00:45', '2021-10-04 11:00:55', 0),
  (102, 0, '2021-10-06 11:00:53', '2021-10-05 11:00:59', 1),
  (102, 0, '2021-10-07 11:00:45', '2021-10-06 11:00:55', 1);
```

思路分析：

1. 要想求每日用户领到的金币数量，只需关注三个特殊节点：连续3天签到+2个金币，连续7天签到+6个金币，7天后领取金币数量为1

- **如何判断是否连续签到3天/7天？**

```sql
WITH t1 AS (
  SELECT 
    uid,
    DATE(in_time) AS dt,
    CASE
     row_number() OVER (PARTITION BY uid ORDER BY DATE(in_time)) % 7 
     when 3 then 3
     when 0 then 7
     else 1
    END AS coin
  FROM tb_user_log
  WHERE
    DATE(in_time) BETWEEN '2021-07-07' AND '2021-10-31'
    AND artical_id = 0 
    AND sign_in = 1
)
SELECT 
  uid,
  DATE_FORMAT(dt, '%Y-%m') AS month,
  SUM(coin) AS coin
FROM t1
GROUP BY uid, DATE_FORMAT(dt, '%Y-%m');
  
```

上面这段代码是对的吗？

注意我们是需要判断**连续签到.**

**而该语句是没有判断连续签到的功能。为什么？**

**假设我们有下面数据**

```sql
'2021-07-07 10:00:00'
'2021-07-08 10:00:00'
'2021-07-11 10:00:00'
```

**如果按照上面的语句执行的话，当日期数据经过row_number排序之后，计算金币数结果如下：**

```sql
date                   rn   coin
'2021-07-07 10:00:00'  1     1
'2021-07-08 10:00:00'  2     1
'2021-07-11 10:00:00'  3     3
```

 这实际上是错误的，因为当签到日期断开时，要重新记录，真正的结果应该是下面这样：

```sql
date                   rn   coin
'2021-07-07 10:00:00'  1     1
'2021-07-08 10:00:00'  2     1
'2021-07-11 10:00:00'  3     1
```

`'2021-07-11 10:00:00'`该日期和`'2021-07-08 10:00:00'`是断开的，所以金币要重新记录。

上面的语句问题在于没有一个判断日期是否连续的逻辑。

**所以我们需要将连续的日期形成同一个组别**

**如何分组？**

```java
date                   rn   
'2021-07-07 10:00:00'  1     
'2021-07-08 10:00:00'  2    
'2021-07-11 10:00:00'  3     
```

**注意到，如果日期连续，那么减去每个日期的排名时，结果日期相同，那么该日期其实就是可以作为一个组别**

```java
date                   rn    group
'2021-07-07 10:00:00'  1    '2021-07-06 10:00:00'
'2021-07-08 10:00:00'  2    '2021-07-06 10:00:00'
'2021-07-11 10:00:00'  3    '2021-07-08 10:00:00'
```

然后，根据用户和日期组别分区再排序，就可以计算金币数了

```java
WITH t1 AS (
  SELECT 
    uid,
    DATE(in_time) AS dt,
     row_number() OVER (PARTITION BY uid ORDER BY DATE(in_time)) as rn
  FROM tb_user_log
  WHERE
    DATE(in_time) BETWEEN '2021-07-07' AND '2021-10-31'
    AND artical_id = 0 
    AND sign_in = 1
),
t2 as (
 select 
     uid,
     dt,
    -- 连续的日期会形成同一个组，然后再对组内进行一次排序。
    case row_number() over(partition by uid, date_sub(dt, interval rn day) order by dt)%7
   when 3 then 3
   when 0 then 7 
   else 1
   end as day_coin
from t1
)
SELECT 
  uid,
  DATE_FORMAT(dt, '%Y-%m') AS month,
  SUM(day_coin) AS coin
FROM t2
GROUP BY uid, DATE_FORMAT(dt, '%Y-%m');
```